<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Entity Relationship Explorer</title>
  <style>
    table {
      margin: .5em;
      padding: .5em;
    }
    tr {
      border: .25em solid black;
    }
  </style>
</head>
<body>
  <p>Please select a schema description data file</p>
  <form>
    <!--
      the one and only event generator which drives this little utility:
      selecting a file with this input fires off code to load the JSON,
      and generate the rest of the page accordingly.
    -->
    <input
        type="file"
        id="file"
        onchange="load_sel( this.files )"
    >
  </form>
  <h1 id="fname"></h1>
  <ul id="tnames"></ul>
  <div id="tdetails"></div>
  <script
      src="https://cdn.jsdelivr.net/npm/ramda/dist/ramda.js"
      crossorigin="anonymous"
  >
  </script>
  <!-- TODO - lock down the Ramda version, then get updated checksum -->
  <!-- TODO integrity="sha384-rKmeYxOQCAwkiEDMEDRGhK9EDXaEssbVFm7tXtZxMveWR8nYSjjsrevOsUZVpcPm" -->
  <script defer>

    // @formatter:off
    //
    // If the setting above, AND, a corresponding preference / configuration are enabled,
    // IntelliJ will try to "help" you format your code LESS (some of us detest its auto-formatting).
    // see:  https://www.google.com/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#q=intellij+disable+auto+format&*
    // e.g. -
    //      http://www.gamefromscratch.com/post/2015/02/01/Preventing-IntelliJ-code-auto-formatting-from-ruining-your-day.aspx
    //      http://stackoverflow.com/questions/3375307/how-to-disable-code-formatting-for-some-part-of-the-code-using-comments

    /** defer an operation to allow the browser to respond to other events between work chunks */
    const defer = function ( work ) {
      setTimeout(
        work,
        0  // no real wait, just allow other events to process
      )
    }

    /** return anchor name based on table name */
    const get_anchor = ( tname ) => (
      `tb_${ tname }`
    )

    /** HTML markup utility functions */
    const m = ( function () {

	  /** set / clear text on an element */
	  const set_text = function ( el, text ) {
		el.textContent = text
		return el
	  }

	  /** append any attributes to an element, pass through the element */
	  const set_attrs = function ( el, attrs ) {
		if ( attrs ) {
		  Object.getOwnPropertyNames(
			attrs
		  ).forEach( function( attr ) {
			el.setAttribute(
			  attr,
			  attrs[ attr ]
			)
		  } )
		} // else: no attributes to add
		return el
	  }

	  /** append any nested element(s) to an element, pass through the element */
	  const set_nest = function ( el, child_els ) {
		console.log( child_els )
		if ( child_els.forEach ) {
		  child_els.forEach( function ( child ) {
			el.appendChild( child )
		  } )
		} else {
		  el.appendChild( child_els )
		}
		return el
	  }

	  /** generate a new element, with optional text or attributes */
	  const gen_el_w_text = R.curry( ( type, text, attrs ) => (
		set_text(
		  set_attrs(
			document.createElement( type ),
			attrs
		  ),
		  text
		)
	  ) )

	  /** generate a new element, nested element(s) or attributes */
	  const gen_el_w_nest = R.curry( ( type, child_els, attrs ) => (
		set_nest(
		  set_attrs(
			document.createElement( type ),
			attrs
		  ),
		  child_els
		)
	  ) )

	  /** generate a list item with nested element(s) */
	  const div = gen_el_w_nest(
		'div',
		R.__,
		null
	  )

	  // Note that the m_* convenience functions generate (HTML) markup.
	  // A word about R.curry / R.partial: it does partial function application via strict currying,
	  // so all arguments must be passed (no variadic function support) to call the underlying function.

	  /** generate a list item with nested element(s) */
	  const li = gen_el_w_nest(
		'li',
		R.__,
		null
	  )

	  /** generate an anchor tag with optional text and attributes */
	  const a = gen_el_w_text( 'a' )

	  /** generate a table (with only a body, no header/footer) with nested element(s) */
	  const table = R.compose( // f * g -- f( g( x ) )
		gen_el_w_nest(
		  'table',
		  R.__,
		  null
		),
		gen_el_w_nest(
		  'tbody',
		  R.__,
		  null
		)
	  )

	  /** generate a table row with nested element(s) */
	  const tr = gen_el_w_nest(
		'tr',
		R.__,
		null
	  )

	  /** generate a table data cell with text */
	  const td = gen_el_w_text(
		'td',
		R.__,
		null
	  )

      return {
        div,
        li,
        a,
        table,
        tr,
        td
      }
    } )()

    /** map the input array and append the result to the given (passed through) anchor */
    const append_map = function ( mapper, anchor_el, in_objs ) {
      in_objs.forEach( function ( obj) {
        anchor_el.appendChild(
          mapper( obj )
        )
      } )
      return anchor_el
    }

    /** generate an entry in the list of table names */
    const gen_table_index = function ( table ) {
      console.log( table )
      return m.li(
        m.a(
          table.name,
          { href: '#' + get_anchor( table.name ) }
        )
      )
    }

    /** generate an entry in the details of table names */
    const gen_table_detail = function ( table ) {
      console.log( table )
      return m.div(
        [
          m.a(
            null,
            { name: get_anchor( table.name ) }
          ),
          m.table(
            m.tr(
              m.td( table.name )
            )
          )
        ]
      )
      // TODO - list references from, and to
    }

    /** force redraw of generated content */
    const redraw = function ( el ) {
      defer( function() {
        // per recipe from https://martinwolf.org/before-2018/blog/2014/06/force-repaint-of-an-element-with-javascript/
        el.style.display = 'none'
        console.log( 'Ignore, accessed for side effect: ' + el.offsetHeight )
        el.style.display = 'block'
      } )
      return el
    }

    /** interpret the schema description object */
    const display_schema = function ( schema ) {
      defer( function () {
        var tnames = document.getElementById( 'tnames' )
        tnames.textContent = null
        tnames.appendChild(
          append_map(
            gen_table_index,
            document.createDocumentFragment(),
            R.sort(
              R.comparator( ( l, r ) => ( l.name < r.name ) ),
              schema.tables
            )
          )
        )
        redraw( tnames )
      } )
      defer( function () {
        var tdetails = document.getElementById( 'tdetails' )
        tdetails.textContent = null
        tdetails.appendChild(
          append_map(
            gen_table_detail,
            document.createDocumentFragment(),
            schema.tables
          )
        )
        redraw( tdetails )
      } )
      // TODO - check for top level related schemas with their own (related) tables
    }

    /** Load the selected file (first item in given list). */
    const load_sel = function ( files ) {
      try {
        const sel_file = files[ 0 ]
        console.log( sel_file )
        document.getElementById(
          'fname'
        ).textContent = sel_file.name
        sel_file.text().then( function ( text ) {
          const schema = JSON.parse( text )
          console.log( schema )
          display_schema( schema )
        } )  // TODO - log any error
      } catch ( e ) {
        console.error( e )
      }
    }

  </script>
</body>
</html>
